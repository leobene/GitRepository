\documentclass[dissertacao,modelo1,brazil]{ThesisPUC}

\usepackage{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\Rset}{\mathbb{R}}
%\newcommand{\Zset}{\mathbb{Z}}

\newcommand{\script}{\emph{script}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\autor{Leonardo de Paula Batista Benevides}
\orientador{Waldemar Celes}
\orientadorR{Celes, Waldemar} 
%TODO: mudar o título
\titulo{Random}
%\subtitulo{Das hiperflorestas at\'{e} complexos celulares}
\dia{21} \mes{Novembro} \ano{2012}

\cidade{Rio de Janeiro}
\CDD{510}
\departamento{Inform\'atica}
\programa{}
\centro{Centro T\'{e}cnico Cient\'{i}fico}
\universidade{Pontif\'{i}cia Universidade Cat\'{o}lica do Rio de Janeiro}
\uni{PUC--Rio}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\banca{
%}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\curriculo{%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\agradecimentos{%}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TODO:
\chaves{%
  \chave{Linguagem visual, Programação por usuários finais}%
}

\resumo{
Este documento apresenta os principais conceitos de
um sistema de \script{} de uma aplicação
voltada para o pós-processamento de simulações de reservatórios de petróleo
e a proposta e implementação de uma ferramenta que disponibilze parte 
dos recursos  obtidos a partir dos \emph{scripts} à usuários não programadores.
A ferramenta implementada  é uma
uma calculadora de propriedades que permite que o usuário gere novas 
propriedades a partir de simples expressões aritméticas desenvolvidas em
uma interface gráfica similar a uma calculadora comum. 
Este documento também apresenta um breve resumo dos estudos feitos acerca
de linguagens de programação visual e a proposta e início de implementação
de uma linguagem de programação visual simplificada.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chavesuk{
  \chave{Visual language, End users pogramming }%
}

\titulouk{A visual programming tool for postprocessing of oil reservoir simulations  }

\resumouk{%
This document presents the main concepts of a 
script system of an application focused on the 
postprocessing of oil reservoir simulations
and the proposal and the implementation of a tool
that provides part of the scripts resources to users that are not programmers.
This tool is an property calculator that lets the 
users generate new properties from simple arithmetic
expressions that are developed in an graphic interface that
looks like an ordinary calculator.
This document also presents a brief summary 
of studies about visual programming languages
and the proposal and the beginning of a
simplified visual programming language.

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\modotabelas{figtab} % nada, fig, tab ou figtab

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\epigrafe{%}
%\epigrafeautor{Wassily Kandinsky}
%\epigrafelivro{Regards sur le pass\'{e}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\chapter{Introdução}

O \textbf{Geresim} \'{e} uma aplica\c{c}\~ao desenvolvida por meio de uma
parceria firmada entre o \textbf{TeCGraf/PUC-Rio}
e a \textbf{PETROBRAS (E\&P/ER)} com o intuito de melhorar o processo de modelagem do escoamento em meio 
poroso em reservat\'{o}rios de petr\'{o}leo. Ele \'{e} constituí\'{i}o de um ambiente de trabalho que permite 
construir, alterar, manter, importar e exportar modelos num\'{e}ricos para os principais simuladores 
comerciais, tirando proveito de uma s\'{e}rie de facilidades voltadas para a agilidade e a efic\'{a}cia 
da montagem dos modelos. Adicionalmente, o \textbf{Geresim} executa uma an\'{a}lise de consist\^{e}ncia que 
elimina a maioria dos erros mais comuns no processo de modelagem e oferece um ambiente para 
analisar modelos e dados de reservat\'{o}rios, utilizando visualiza\c{c}\~{o}es bidimensionais de mapas 
e se\c{c}\~{o}es, tridimensionais do modelo ou gr\'{a}ficas de elementos do modelo\cite{Tecg06}. 

Uma das aplica\c{c}\~{o}es com maior usabilidade no \textbf{Geresim} \'{e} um poderoso sistema de \emph{scripts} que possibilita
acesso program\'{a}vel aos dados dos modelos de reservat\'{o}rios visualizados e disponibiliza diversos 
recursos como gera\c{c}\~{a}o de dados de forma procedimental e flexibiliza\c{c}\~{a}o
nas opera\c{c}\~{o}es com os dados.
Esse acesso program\'{a}vel \'{e} feito atrav\'{e}s da linguagem de programa\c{c}\~{a}o \textbf{Lua} \cite{Ieru03}.

%TODO : melhorar esse paragrafo
%nocoes de orientaçao a objetos, iteradores de lua
No entanto, como requer certo conhecimento de técnicas de programação do usuário e este na maioria das
vezes tem pouca ou até mesmo nenhuma experiência como programador, 
o sistema de \emph{scripts} muitas vezes 
acaba sendo subutilizado e os que necessitam do mesmo acabam delegando aos próprios desenvolvedores 
do software a implementação de novos \emph{scripts} de programação.

Nesse contexto, torna-se interessante e necessário (pois, foi sugerido pelo próprio cliente) o estudo
de alternativas à programação textual % desenvolvimento de scripts através de mecanismos de programação visual
que disponibilize ao usuário não programador pelo menos parte dos recursos do sistema de \emph{scripts}
do \textbf{Geresim}.
%O uso de programação visual tem se mostrado interessante em sistemas que apresentem um domínio
%específico, como o descrito acima, pois é possível manter-se dentro do estilo de comunicação do
%domínio utilizando artefatos visuais que reflitam necessidades particulares, diagramas e o
%vocabulário específico do domínio sem nunca precisar deixar esse estilo de comunicação [GrPe96].
%TODO : melhorar esse paragrafo
Por isso, esse projeto teve como metas principais pesquisar e desenvolver ferramentas
que cumpram esse objetivo.

Este trabalho foi dividido da seguinte forma: a seção 2 apresenta de forma breve o atual sistema
de script do \textbf{Geresim}; a seção 3 descreve a implementação e funcionamento de uma calculadora de 
propriedades desenvolvida no projeto; a seção 4 apresenta um breve resumo dos estudos feitos
acerca de lingugens de programação visual; a seção 5 apresenta  o início da 
implementação de uma ferramenta de programação visual; a seção 6 apresenta algumas conclusões
e propostas de trabalhos futuros.


\chapter{O sistema de Scripts}

O sistema de \emph{scripts} do \textbf{Geresim} possibilita acesso programável aos dados dos 
modelos de reservatório visualizados. Esse acesso programável é feito através da 
linguagem de programação \textbf{Lua}. Por isso o sistema disponibiliza diversos recursos
de programação sendo possível a implementação de \emph{scripts} diversos que podem
acessar todos os dados dos modelos de reservatório.

Assim é possível gerear dados de forma procedimental, como cirar novos
modelos e novos dados a serem associados a modelos, manipular dados de forma 
flexível, como usá-los como operandos de diversas operações sem muitas restrições
e criar \emph{scripts} temporários. Por isso o sistema pode funcionar como uma máquina
de calcular que opera com os dados dos modelos, recurso que será mais discutido
na seção 3.

Nessas seção será feita uma rápida descrição da linguagem de programação \textbf{Lua} e 
uma apresentação do funcionamento do sistema de \script{} do \textbf{Geresim}.

\section{Lua}


\textbf{Lua} é uma linguagem de programação poderosa, rápida e leve, projetada justamente para estender aplicações.
Combina sintaxe simples para programação procedural com poderosas construções para descrição de dados 
baseadas em tabelas associativas e semântica extensível. \textbf{Lua} é tipada dinamicamente, é interpretada a 
partir de bytecodes para uma máquina virtual baseada em registradores, e tem gerenciamento automático 
de memória com coleta de lixo incremental. Essas características fazem de \textbf{Lua} uma linguagem ideal 
para configuração, automação (\emph{scripting}) e prototipagem rápida. A linguagem
é usada em muitas aplicações
industriais, com ênfase em sistemas embutidos e jogos, onde é atualmente a linguagem de
\script{} mais usada. \textbf{Lua} tem uma merecida reputação de ótimo desempenho, em vários benchmarks 
aparece como a linguagem mais rápida dentre as linguagens de \script{} interpretadas.
\cite{Lua}

Mais do que apenas estender aplicações, \textbf{Lua}
também suporta uma abordagem de desenvolvimento de software 
baseada em componentes, onde é possível criar aplicações
juntando componentes de alto-nível pré-existentes.
Normalmente esses componentes são escritos em linguagens 
compiladas e estaticamente tipadas como \textbf{C} ou \textbf{C}++.
Assim, \textbf{Lua} pode ser usada conectar tais componentes, 
que normalmente representam conceitos mais concretos
e de baixo nível (como por exemplo estruturas de dados) que não estão sujeitos a muitas alterações
durante o desenvolvimento do programa e normalmente exigem um maior poder de processamento.
\cite{Ieru03}

%talvez falar mais sobre os recurso e estilo de programação, meta-mecanismos e tabelas

%\newpage

%More than being an extensible language, Lua is also a glue language. Lua supports a component-based approach to software development, where we create an application by gluing together existing high-level components. Usually, these components are written in a compiled, statically typed language, such as C or C++; Lua is the glue that we use to compose and connect those components. Usually, the components (or objects) represent more concrete, low-level concepts (such as widgets and data structures) that are not subject to many changes during program development and that take the bulk of the CPU time of the final program. Lua gives the final shape of the application, which will probably change a lot during the life cycle of the product. However, unlike other glue technologies, Lua is a full-fledged language as well. Therefore, we can use Lua not only to glue components, but also to adapt and reshape them, or even to create whole new components. 

\section{Conceitos básicos do sistema de Script}

O sistema de macros do \textbf{Geresim} provê acesso a diversos objetos que 
representam o modelo e seus dados. Para cada objeto, tem-se acesso a suas 
informações e a um conjunto de métodos que permitem a 
manipulação alteração das informações associadas. Os objetos a que se tem 
acesso no sistema de macros são: 

\begin{itemize}
  \item \textbf{Model:} 
  objeto que representa um modelo de reservatório;
  \item \textbf{Field:} 
  objeto que representa um campo do modelo;
  \item \textbf{Region:} 
  objeto que representa uma região do modelo;
  \item \textbf{Well:} 
  objeto que representa um poço do modelo;
  \item \textbf{Completion:} 
  objeto que representa uma completação de um poço do modelo;
  \item \textbf{Data:}
  objeto que representa um conjinto de valores de propriedades, podendo ser
  dos seguintes tipos:
  \begin{itemize}
    \item \textbf{MapProp:}
    propriedade de mapa, representada por um vetor de 
    dados de dimensão 4: ni x nj x nk x número de timesteps\footnote{explicação de timestep} de mapa; 
    \item \textbf{FieldProp:}
    propriedade de campo, representada por um vetor de 
    dados de dimensão 1: número de timesteps de poço; 
    \item \textbf{RegionProp:}
    propriedade de região, representada por um vetor de 
    dados de dimensão 2: número de regiões x número de timesteps de 
    poço;  
    \item \textbf{GroupProp:}
    propriedade de grupo, representada por um vetor de 
    dados de dimensão 2: número de grupos x número de timesteps de 
    poço;  
    \item \textbf{WellProp:}
    propriedade de poço, representada por um vetor de 
    dados de dimensão 2: número de poços x número de timesteps de 
    poço; 
    \item \textbf{CompProp:}
    propriedade de completação, representada por um 
    vetor de dados de dimensão 3: número de poços x número de 
    máximo de completações por poço x número de timesteps de poço;
    \item \textbf{ExtraProp:}
    propriedade avulsa, representada por um vetor de 
    dados de dimensão 1: número de timesteps de poço;
  \end{itemize}
  \item \textbf{Slice:}
  referência para uma ``fatia'' de um determinado conjunto de dados.
\end{itemize}

Pode-se ainda criar referências para outras porções de um dado. Por exemplo, é 
válido criar uma referência para um mapa associado a um determinado timestep.

%TODO: melhorar esse paragrafo
Existem dois tipos de vetores de dados: dados originais associados ao modelo e 
dados criados dinamicamente pelo sistema de \script{}. Os dados originais podem 
ser consultados, mas não podem ser alterados. Já os dados criados 
dinamicamente podem ser livremente alterados. Analogamente, referências a 
dados originais não são editáveis, enquanto que referências a dados criados 
dinamicamente são editáveis (na verdade, altera-se o vetor de dados 
referenciado). 

Logicamente, o programa de \script{} pode também incluir a manipulação de 
valores dos tipos existentes em \textbf{Lua}: booleanos, valores escalares, cadeias de 
caracteres (\emph{string}), entre outros. 

\section{Acesso e criação de dados}

%TODO: melhorar esse paragrafo
O objeto \emph{Model} representa um resultado de simulação, com suas propriedades 
de mapa e de poço. A função que implementa o \script{} recebe um ou mais 
modelos como parâmetro de entrada e a partir desses objetos \emph{Model}, tem-se acesso 
a seus atributos e seus métodos.

É através dos atributos de um objeto \emph{Model} que se dá o acesso programável aos dados
dos modelos de reservatório. Esses dados não podem ser alterados no \script, é possível apenas
consulta-los e usar os valores retornados. Assim é possível acessar dados de geometria,
como o número de células nas direções I, J ou K, acessar dados relacionados a timesteps,
acessar dados relacionados aos demais objetos do modelo, como o número de poços ou
de regiões, acessar os próprios objetos e também a todas as propriedades do modelo.

Como dito acima, o objeto \emph{Model} também provê um conjunto de métodos
que possibilitam o acesso à estrutura do reservatório, a criação de novos 
modelos, criação de novos vetores de propriedade, verificar a existência
de timesteps e propriedades e associar os novos dados vetoriais criados
durante o \script{} aos modelos.

\section{Vetores de dados de propriedades}

Como visto anteriormente, os valores das propriedades são representados em vetores de dados. 
Vetores de propriedade de mapa, por exemplo, têm dimensão 4 (ni x nj x nk x número de timesteps de 
mapa) e só podem ser usados em operações com outros vetores de mapa de 
mesmas dimensões. É permitida a criação de ``fatias'' (\emph{slices}) que fazem 
referência a uma parte de um vetor 4D, ou seja, pode-se representar uma 
propriedade de uma camada de um reservatório através de uma referência ao 
vetor 4D, onde a terceira dimensão é fixada.

As dimensões de uma fatia que representa uma camada são: ni x nj x 1 x número 
de timesteps de mapa. Conceitualmente, uma camada é um vetor 3D, já que o 
índice k não varia. No entanto, internamente, ela é representada por um vetor 
4D, como se os valores associados à camada em questão fossem replicados para 
as demais camadas do grid. Desta forma, pode-se fazer operações entre um grid 
e uma camada específica. Generalizando, pode-se fazer operações entre vetores 
e fatias de vetores de mesmas dimensões. Também é possível associar uma fatia 
a um modelo, para ser visualizada através da interface gráfica. Neste caso, os 
valores são replicados ao longo das dimensões fixadas.

Conceitualmente, uma propriedade de campo é um vetor 1D (número de 
timesteps), uma propriedade de região é um vetor 2D (número de regiões x 
número de timesteps), uma propriedade de grupo é um vetor 2D (número de 
grupos x número de timesteps), uma propriedade de poço é um vetor 2D 
(número de poços x número de timesteps), e uma propriedade de completação é 
um vetor 3D (número de poços x número de completações x número de 
timesteps).

Em todas as operações que envolvem dois vetores de dados como operandos, a 
operação só é possível se os timesteps associados aos vetores forem compatíveis. 
O primeiro operando é usado com referência na operação. Para cada timestep 
existente no primeiro operando, deve haver um timestep correspondente no 
segundo operando. A correspondência entre timesteps é feita buscando-se a 
ocorrência entre datas próximas, dentro de uma determinada tolerância, que pode
ser configurada pelo programador. Se a operação entre dois vetores não puder ser
realizada, o sistema reporta uma mensagem de erro. 
De posse de um vetor de dados, pode-se fazer diversas 
operações e invocar diversos métodos associados.
É possível realizar as operações aritméticas 
\footnote{Também é possível realizar operações aritméticas entre vetores
de propriedades e valores escalares.}
de soma, subtração, multiplicação, divisão e potenciação.
Essas operações resultam em um novo vetor de dados, de mesmas
dimensões, onde cada valor representa a operaçãoaplicada aos
valores associados aos vetores fornecidos.\cite{Tecg06}

Estão disponíveis também operadores relacionais e lógicos 
e alguns métodos de manipulação de valores.

%Escrever sobre o atual sistema de script. \cite{Tecg06}

\chapter{Calculadora de propriedades}

Como visto anteriormente, um recurso interessante do sistema de \script{} é 
a possibilidade de usá-lo como uma espécie de máquina de calcular que opera
sobre os dados de modelos de reservatórios. Sendo assim, a primeira solução
encontrada para resolver o problema apresentado na introdução, oferecer
parte dos recursos do sistema de \script{} para o usuário não programador,
foi implementar justamente uma calculadora de propriedades onde o resultado
das operações fossem propriedades que pudessem ser posteriormente visualizadas pelo
usuário. Sendo assim, a ferramenta proposta deveria ter uma interface gráfica
na forma de uma calculadora e gerar um código compatível com o sistema
de \script{} e que obviamente resultasse na propriedade desejada pelo
usuário.

\section{Sintaxe das expressões}

Inicialmente a calculadora foi pensada para funcionar apenas para propriedades de
mapa. As propriedades de mapa são valores associados às células do modelos, por
isso o acesso aos dados dessas propriedades é sempre independente dos demais
objetos vistos na seção 2.2. Portanto, a sintaxe das expressões deveria ser
a sintaxe comum de expressões aritméticas levemente modificada para atender três
requisitos: 

\begin{enumerate}
  \item Possibilitar o uso não somente de propriedades mas também de ``fatias'' 
  de propriedades com o timestep fixado.
  \item Permitir o uso de funções, para incluir outras funcionalidades do sistema
  de \script{}.
  \item Ser compatível com \textbf{Lua}, para facilitar a implementação.
\end{enumerate}

As ``fatias'' foram incluidas da seguinte forma: uma fatia é o nome de propriedade
(identificador) seguido de uma data entre aspas, como por exemplo:
 SO``10/10/2010''.
Em \textbf{Lua}, essa expressão é encarada como uma chamada de função.

Posteriormente, foram  incluídas na calculadora também propriedades de campo,
região, grupo e poço. No caso de tais propriedades, abriu-se a possibilidade de incluir
também os respectivos elementos nas expressõs. Dessa manera, a fatia da propriedade associada
a um elemento (grupo, região ou poço) seria referenciada da seguinte maneira: nome
do elemento seguido do nome da propriedade entre colchetes, como por exemplo:
WELL[BHP]. Isso indicaria a fatia da propriedade BHP associada ao poço WELL.
Em \textbf{Lua}, essa ecpressão é encarada como uma indexação de uma tabela.

\section{Implementação}

A calculadora foi implementada na linguagem de programação \textbf{Lua} e a interface gráfica
foi implementada utilizando o toolkit para construção de interfaces gráficas IUP.
\cite{IUP}
A implementação foi dividida em três módulos: Calculator.lua, que implementa a interface
gráfica e controla a entrada de dados do usuário, CalcComp.lua, responsável pela geração
de código e validação das expressões e por último CalcLib.lua, que implementa algumas funções para
serem incluidas no sistema de \script{} que garantem o funcionamento do código gerado.

\subsection{Módulo Calculator.lua}

    \begin{figure}[!htb]
    %\begin{figure}
      \centering
      \includegraphics[bb= 0 0 534 257,width=\textwidth]{calc1.JPG}
      \caption{Interface da Calculadora}
      \label{interface}
    \end{figure}

A interface é composta pelos seguintes campos: 
\begin{itemize}
  \item Um campo de texto onde é possível entrar o nome da nova propriedade,
  caso não seja especificado um nome, é usado a própria expressão como nome.
  \item Lista que indica o tipo de propriedade que será calculada, atualmente
  os tipos suportaqdos são propriedade de mapa, campo, região e poço.
  \item Um toggle %TODO: achar uma traduçao para isso
  e a lista de elementos, que é preencida de acordo com o valor da lista de tipos,
  se o tipo for mapa, esses dois controles não são habilitados, pois não se aplicam
  a propriedades destes tipos.
  \item Lista de propriedades, que é preenchida de acordo com o valor da lista de tipos.
  \item Um toggle e lista de timesteps, que é preenchida de acordo com o valor da lista de tipos.
  \item Botão de inserir propriedade.
  \item ``Teclado'' formado por botões que disponibilizam os números, os operadores e algumas
  funções para o usuário.
  \item Um campo de texto onde pode-se visualizar a expressão.
  \item Botões de calcular e limpar expressão.
\end{itemize}

A interface funciona da seguinte forma: o usuário pode entrar números e operadores ou movimentar
o cursor livremente através de seu teclado ou clicando no teclado virtual da interface.
Já a entrada de variáveis(propriedades) e funções só pode ser feita através da interface gráfica.
O objetivo disso é evitar a geração de códigos inconsistentes.

Para se inserir funções basta-se clicar no respectivo botão da função no teclado virtual para
que a função seja inserida na posição corrente do cursor.

Para se inserir propriedades é preciso clicar no botão inserir ao lado da lista de timesteps.
O valor inserido depende dos valores das listas e dos toggles. Se nenhum dos toggles estiver
habilitado, será inserido apenas o nome da propriedade selecionada na lista de propriedades.
Se o toggle da lista de elementos estiver habilitado, será inserido a propriedade selecionada
na lista de propriedades indexando o elemento selecionado na lista de elementos
(exemplo: WELL[BHP]).
Caso o toggle de timestep esteja habilitado, será adicionado ao fim a data selecionada
na lista de timesteps (exemplo: SO``10/10/2010'').

Para que não haja casos de entrada de números, operadores, funções ou propriedades em 
posições indesejadas (como por exemplo no meio do nome de uma propriedade) foram implementadas
algumas funções que controlam o movimento e posição do cursor, evitando cenários desse tipo.

%TODO: nao falei que as listas são preenchidas com vlores referentes ao modelo aberto.

\subsection{Módulo CalcComp.lua}

Quando se pensa em geração de código para um problema como este, a primeira abordagem que
nos vem a cabeça é compilar  as expressões e gerar o código desejado a partir delas.
Porém, compilar códigos, por mais simples que sejam as expressões
encontradas nesse caso, não é uma tarefa trivial. O desenvolvimento de um mini-compilador 
envolveria a implementação de um parser,
a elaboração de uma gramática, o uso de técnicas como criação de árvores de sintaxe
e etc. Por isso, a abordagem que foi seguida vai praticamente na direção oposta.
Em vez de compilar as expressões e gerar um código de \script{} a partir delas
, o que fizemos foi adaptar o ambiente do sistema de \script{} 
para que as próprias expressões pudessem ser executadas dentro desse ambiente
e gerar o resultado esperado. É por isso que era imprescindível que as
expressões fossem compatíveis com \textbf{Lua}.

As adaptações são feitas da seguinte maneira: é desempenhada uma iteração sobre
os identificadores presentes na expressão (nomes de propriedades ou dos demais
elementos, como nomes de poços), é verificado se o identificador se refere a uma propriedade
ou a um elemento e então é gerado um código que inicializa uma variável local de mesmo
nome da propriedade ou elemento com uma chamada de função que retorna um objeto
especial que possibilite a execução do código da expressão. Essa função recebe como parâmetro
uma referência para o objeto que representa o modelo de reservatório, um \emph{string}
indicando o tipo de dado sendo trabalhado (propriedade de mapa, de poço e etc) e um
\emph{string} contendo o nome da propriedade ou objeto. Além disso, também é gerado
o código que armazena o resultado da expressão em uma variável temporária e
o da chamada de função que associa o vetor de dados resultante ao modelo
para ser posteriormente visualizado.

Segue abaixo o exemplo de um código gerado pelo módulo para a expressão OIL1[QO] + QW``10/07/1981'':

\begin{verbatim}
  calc.GetMacroEnv()
  local OIL1 = calc.CreateElem(rf,"well","OIL1")
  local QO = calc.CreateProp(rf,"well","QO")
  local QW = calc.CreateProp(rf,"well","QW")
  local newprop = OIL1[QO] + QW"10/07/1981"
  calc.AttachProp(rf,temp,'newprop','well')
\end{verbatim}

Nesse caso, QO e QW são propriedades de poços, OIL1 é o nome de um poço e rf representa
um objeto do tipo \emph{Model}.

A implementação dessas funções e dos objetos retornados por elas será discutida
na próxima seção.

%TODO: explicar melhor o teste
O módulo também disponibiliza uma função que testa a expressão com o intuito de 
prevenir erros de sintaxe e que funções sejam chamadas sem que seus parâmetros tanham
sido especificados.

%descrição da geração de código.
%explicar que o código não eh compilado, o que 
%acontece eh a adicao de algumas linhas de código para
%que a execução da propria expressao já gere o resultado
%esperado.

\subsection{Módulo CalcLib.lua}

O módulo CalcLib.lua é responsável por implementar as funções presentes
no código gerado pelo módulo CalcComp.lua. Essas funções servem para
adaptar o ambiente do sistema de \script{} para que as próprias expressões
possam ser executadas dentro desse ambiente e gerar o resultado esperado.
As funções são armazenadas em uma tabela que é inserida no ambiente de
\script{} (tabela calc). O principal desafio de implementar esse módulo
foi desenvolver objetos que se comportassem ora como operandos de 
expressões aritméticas e ora como funções (no caso de propriedades
com o timestep especificado, que é interpretado em  \textbf{Lua} como uma chamada
de função). Uma limitação que também teve que ser superada foi a de que,
em operações aritméticas entre vetores de dados e escalares no sistema de \script{},
os escalares devem sempre ser o segundo operando.

Para solucionar esses problemas, foi utilizado o recurso de meta-mecanismos
presente em \textbf{Lua}, que nos permite especificar como determinados objetos devem se
comportar em algumas situações. Isso é disponibilizado por meio da implementação 
de \emph{metatables}, que são tabelas que definem através de seus \emph{metamétodos}
como os objetos associados a ela devem se comportar.

Os objetos retornados pela função \emph{CreateProp}, que representam as
propriedades nas expressões, são tabelas que possuem campos que
especificam o nome da propriedade, o tipo da propriedade e se o valor utilizado
nos cálculos será a propriedade associada a um determinado elemento ou será
o vetor de dados inteiro. Seu comportamento (determinado por sua \emph{metatable})
é o seguinte: 

\begin{itemize}
  \item O metamétodo de todas as operações binárias ajusta a ordem dos
  termos, armazena o resultado da operação em um objeto intermediário
  e o retorna.
  \item O metamétodo responsável pela situação em que o objeto é chamado 
  como uma função, armazena a ``fatia'' da propriedade referente ao timestep passado como
  parâmetro em um objeto intermediário e o retorna.
  \item O metamétodo responsável pelo tratamento de indexações %inexistentes
  é o responsável por buscar os vetores de dados que serão usados nos cálculos, por 
  isso os demais metamétodos acessam esses valores apenas indexando a própria tabela. 
\end{itemize}

O objeto intermediário, que é apenas uma tabela que armazena o resultado das operações,
se mostrou necessário para resolver a limitação da ordem dos termos em operações envolvendo
escalares citada acima. Ele é associado à mesma \emph{metatable} do objeto que representa as
propriedades e por isso sempre ajusta a ordem dos termos nas operações.

%TODO: melhorar esse paragrafo
Os objetos que representam nas expressões os elementos (poços, regiões e etc), 
são criados pela função \emph{CreateElem}. Eles são tabelas contendo campos
com o nome do elemento, o seu tipo e uma referência para o modelo que pertence.
A \emph{metatable} que é associada a eles contém apenas o metamétodo responsável 
pelo tratamento de indexações. Ao ser indexada por um objeto que representa uma propriedade,
esse metamétodo extrai o nome da propriedade e cria um novo objeto para mesma preopriedade
(chamando a função \emph{CreateProp}) porém especificando que a propriedade está 
associada agora ao elemento. Portanto, o vetor de dados utilizado nos cálculos será
referente a ``fatia'' da propriedade referente a esse elemento.

A função \emph{AttachProp} associa o resultado da expressão ao modelo. 

Este módulo também inplementa as funções disponíveis na interface da calculadora:

\begin{itemize}
  \item \textbf{max}: retorna o maior valor encontrado dentre os vetores de dados passados como
  parâmetros.
  \item \textbf{min}: retorna o menor valor encontrado dentre os vetores de dados passados como
  parâmetros.
  \item \textbf{sum}: retorna o somatório dos valores do vetor de dados.
  \item \textbf{abs}: retorna um novo vetor de dados de mesma dimensões do vetor passado como
  parâmetros com os valores sendo igual aos respectivos valores absolutos do vetor original.
  \item \textbf{sqrt}: retorna um novo vetor de dados de mesma dimensões do vetor passado como
  parâmetros com os valores sendo igual às respectivas raizes quadradas dos valores do vetor original.
  \item \textbf{delta}: retorna um novo vetor de dados de mesma dimensões do vetor passado como
  parâmetros com os valores sendo igual diferença entre posições vizinhas.
\end{itemize}

\chapter{Linguagens de Programação Visual}

Ultimamente o uso de ferramentas de programação visual vem crescendo cada vez mais,
principalmente em aplicações voltadas para áreas da engenharia como \emph{LabVIEW},
\emph{Simulink}, \emph{CircuitMaker} entre outros.
%Mesmo sem ter apresentado muito sucesso
Mesmo tendo apresentado relativa dificuldade
na resolução de problemas de grande porte
o uso destas ferramentas em sistemas que apresentam um domínio específico,
como as citadas acima, tem se mostrado bastante interessante pois é possível
manter-se dentro do estilo de comunicação do domínio utilizando artefatos 
visuais que reflitam necessidades particulares, diagramas e o vocabulário
específico do domínio 
sem nunca precisar deixar esse estilo de comunicação. Além disso,
linguagens de programação visual costumam ser mais intuitivas e
de mais fácil aprendizado do que linguagens de programação convencionais.

Pelos motivos citados acima, e pela calculadora de propriedades oferecer
relativamente poucos recursos ao usuário, se mostrou interessante um
estudo dessas ferramentas de programação visual e investigar se esse
tipo de recurso solucionaria o nosso problema.

Dentre os sistemas que utilizam programação visual, o que tem se destacado mais
é o \emph{LabVIEW (Laboratory Virtual Instrument Engineering Workbench)} [WhNF06], 
que é um ambiente de programação visual muito usado nos campos de aquisição de 
dados, controle de instrumentos e automação industrial. 
Por ser um instrumento amplamente usado por engenheiros em diversas áreas,
e como esses são os usuários finais do \textbf{Geresim}, essa ferramenta
se mostra uma interessante fonte de pesquisa e um possível modelo a ser seguido, 
já que é possível que parte dos usuários finais tenha uma certa experiência
com o \emph{LabVIEW}.

A linguagem de programação do \emph{LabVIEW}, chamada de G, é formada por elementos
visuais e textuais. Os elementos visuais são basicamente pequenas caixas (que 
podem representar valores, operadores e chamadas de funções) e linhas que as conectam. 
Elementos compostos como funções condicionais e de repetição (loop) são representados
por grandes caixas retangulares cercando o corpo da composição.

A linguagem segue o paradigma de fluxo de dados. O princípio central do paradigma
é definir a computação como um conjunto de dependências de dados. Um programa 
escrito nesse paradigma define um grafo de nós operadores (funções) unidos por 
arcos conectores. Os arcos são as dependências de dados. Assim o paradigma de fluxo
de dados expressa computação como uma série de transformações nos valores dos dados. 
Não há conceitos como variáveis, ponteiros e atribuição, o foco está em quais funções 
serão aplicadas nos valores para produzir o retorno esperado. Outra característica 
desse paradigma é o paralelismo. A ordem de execução é baseada somente nas dependências
de dados, o que é relativamente similar ao design de circuitos elétricos.

Conceitualmente os programas desenvolvidos no \emph{LabVIEW} são compostos de funções,
que recebem o nome de instrumentos virtuais (VIs).
O código de um VI consiste basicamente de três elementos: terminais, nós e fios conectores.
Os elementos terminais são os valores manipulados, podendo ser valores de entrada, saída ou
valores constantes. Esses elementos são representados por pequenas caixas coloridas com a 
cor do tipo do terminal (por exemplo, laranja para números). Os nós são operadores, chamados 
de função e nós estruturais (if-then-else, case, while etc). Operadores e chamadas de função 
são representados por ícones com etiquetas ou imagens, e os nós estruturais são representados 
por grandes caixas retangulares que delimitam a composição que deve ser executada dentro 
da estrutura. Os fios conectores são usados para ligar terminais e nós formando expressões.

\chapter{Início da implementação de uma VPL}

Após o estudo de VPLs e e algumas experiências utilizando o \emph{LabVIEW}
(na matéria Automação Industrial, cursada nesse período), foi iniciada
a implementação de uma VPL bastante simplificada que segue o paradigma de
fluxo de dados. Infelizmente não houve tempo suficiente para desenvolver
mais a ferramenta e por isso a implementação econtra-se em estado inicial.

Ao contrário do que foi feito na calculadora de propriedades, inicialmente
seria implementado algo mais genérico para depois ser especializado para
o ambiente de pós-processamento do \textbf{Geresim}. A princípio, a linguagem
seria composta apenas de blocos e fios conectores que denotariam
as dependências de  dados entre os blocos. Um bloco poderia ter
mais de um dado de entrada e mais de um dado de saída.
Sua compilação geraria um código \textbf{Lua}.

No código gerado, cada bloco seria representado por uma tabela.
Essa tabela aramzenaria a função associada ao bloco e uma lista
de objetos parâmetros, que seriam tabelas armazenando uma referência
a outro bloco e o índice do dado de saída deste outro bloco. 
Todos os blocos estariam associados a uma \emph{metatable} cujo
metamétodo de indexação executaria a função do bloco gerando assim
os dados de saída. Porém, antes de poder executar a função associada
a este bloco, seria preciso obter todos os parâmetros. E isso seria
feito iterando a lista de parâmetros e indexando os respectivos
blocos com os respectivos índices. Caso os dados de saída desses
demais blocos não estejam disponíveis, o metamétodo de indexação agiria
então nesses blocos. Logo, recursivamente toda a cadeia de blocos seria
executada. Dessa maneira, a compilação seria apenas uma iteração sobre os fios
conectores e a partir deles se geraria a lista de parâmetros de cada bloco.

A partir da base descrita acima, já seria possível implementar um bloco
que desempenhe a função de um operador condicional e talvez seja
possível implementar um bloco de iteração.

No atual estágio da implementação é possível manipular os blocos
com o mouse e conecta-los com os fios conectores. É possível também
manipular blocos já conectados, fazendo com que os fios conectores se
redesenhem se ajustando à nova disposição dos blocos.
Essa implementação foi desenvolvida em \textbf{C}++, utilizando a API gráfica
\emph{OpenGL}.\cite{OpenGl} 
A parte \textbf{Lua} ainda não foi desenvolvida.


\chapter{Considerações finais e projetos futuros}

Neste trabalho foi apresentado um sistema de \script{} de uma aplicação
voltada para o pós-processamento de simulações de reservatórios de petróleo (\textbf{Geresim})
e a proposta e implementação de uma ferramenta que disponibilza parte 
dos recursos  obtidos a partir dos \emph{scripts} à usuários não programadores.
Essa ferramenta é
uma calculadora de propriedades que permite que o usuário gere novas 
propriedades a partir de simples expressões aritméticas desenvolvidas em
uma interface gráfica similar a uma calculadora comum. A ferramenta
ainda não foi utilizada por usuários finais, mas já está integrada ao
sistema e após ser testada e aprovada por outros membros da equipe de desenvolvimento da
aplicação criou uma boa expectativa em relação ao cumprimento de seu objetivo.
A ferramenta estará disponível na próxima versão do programa, que
será lançada em breve.

Adicionalmente, foram feitos estudos acerca de linguagens de programação visual.
Dentre os sistemas que utilizam esse recurso, o que se mostrou mais interessante
foi o \emph{LabVIEW}, pois é amplamente usado por usuários que apresentam um perfil
similar aos usuários do \textbf{Geresim}.
Após esse estudo foi iniciada a 
implementação de uma VPL bastante simplificada que segue o paradigma de 
fluxo de dados. Infelizmente não houve tempo suficiente para desenvolver mais 
a ferramenta e por isso sua finalização passa a ser um projeto para o futuro.

Outro projeto futuro é aumentar o escopo de atuação da calculadora
incluindo as propriedades de completção e incluindo a opção de
se trabalhar com camadas e seções das propriedades de mapa.

\arial
\bibliography{pf}

\normalfont
%\begin{thenotations}
% %------------------------------------------------------------------------------%
% \section*{Simplicial Complex}
% %------------------------------------------------------------------------------%
% %
% \noindent
% \begin{tabular}{ll}
% \mathbb{R} & conjunto dos números reais \\
% \end{tabular}
%
%\end{thenotations}
%\printindex

\appendix

\chapter{Exemplos práticos}

\section{Cálculo da razão gas-oleo (RGO)}

Expressão: QG / QO

Código gerado:

\begin{verbatim}
calc.GetMacroEnv()
local QG = calc.CreateProp(rf,"well","QG")
local QO = calc.CreateProp(rf,"well","QO")
local RGO = QG /QO 
calc.AttachProp(rf,RGO,'RGO','well')
\end{verbatim}

\section{Cálculo sedimentos básicos e água (BSW)}

Expressão: QW /(QW + QO )

Código gerado:

\begin{verbatim}
calc.GetMacroEnv()
local QW = calc.CreateProp(rf,"well","QW")
local QO = calc.CreateProp(rf,"well","QO")
local BSW = QW /(QW + QO )
calc.AttachProp(rf,BSW,'BSW','well')
\end{verbatim}

\section{Cálculo do volume de óleo em condições de reservatório}

Expressão: H * PHI * SO * DX * DY

Código gerado:

\begin{verbatim}
  calc.GetMacroEnv()
  local H = calc.CreateProp(rf,"map","H")
  local PHI = calc.CreateProp(rf,"map","PHI")
  local SO = calc.CreateProp(rf,"map","SO")
  local DX = calc.CreateProp(rf,"map","DX")
  local DY = calc.CreateProp(rf,"map","DY")
  local temp = H *PHI *SO *DX *DY
  calc.AttachProp(rf,temp,'H *PHI *SO *DX *DY ','map')
\end{verbatim}



\begin{figure}
   %\includegraphics*[width=\linewidth]{calc1.PNG}
   %\includegraphics[width=2cm]{vis1.JPG}
   \includegraphics[bb= 0 0 523 348,width=\textwidth]{vis4.JPG}
   \caption{Exemplo de visualização}
   %\label{visualização}
 \end{figure}



\end{document}
